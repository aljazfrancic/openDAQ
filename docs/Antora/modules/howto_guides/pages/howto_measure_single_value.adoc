= Measure a single value

OpenDAQ offers a variety of solutions for reading Signal values, including Readers. 

For developers requiring access to only the most recent value, the Signal and Data Packet interfaces provide a method named `getLastValue` (`last_value` in Python).

[#last_value_signal]
== Getting the last value of a Signal

When the `getLastValue` method (`last_value` in Python)  is called on a Signal, it yields an `IBaseObject` containing the last value.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
----
Python::
+
[source,python]
----

----
====

[#last_value_data_packet]
== Getting last value of a Data Packet

Similar is true when calling the `getLastValue` method (`last_value` in Python)  on a Data Packet.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Data Packet
auto lastValue = packet.getLastValue();
----
Python::
+
[source,python]
----

----
====

[#printing_the_last_value]
== Printing the last value

No matter the source (either the Signal or the Data Packet), the resulting variable can be, for example, printed into the console.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Print last value
std::cout << "lastValue: " << lastValue << std::endl;
----
Python::
+
[source,python]
----

----
====

[#casting_the_last_value]
== Casting the last value and using the cast variable

In C++, the function `getLastValue` returns an object of type `IBaseObject`. To access it's underying members and methods, one must explicitly cast it into the appropriate type. However, in Python, this is not necessary due to dynamic typing.

The underlying type of the `IBaseObject` we get from our `getLastValue` call can be cast into either:

* `IFloat` if the type is `Float32` or `Float64`
* `IInteger` if the type is `Int8` through `Int64` or `UInt8` through `UInt64`
* `IComplexNumber` if the type is `ComplexFloat32` or `ComplexFloat64`
* `IRange` if the type is `RangeInt64`
* `IStruct` if the type is `Struct`
* `IList` of the aforementioned types if there is exactly one dimension in the single value

An example of casting the `lastValue` object into an `IFloat` object:

[tabs]
====
Cpp::
+
[source,cpp]
----
// Cast to IFloat
auto number = lastValue.asPtr<IFloat>();
----
Python::
+
[source,python]
----

----
====

In the above example, the Data Descriptor of the Data Packet or its Signal on which `getLastValue` (`last_value` in Python) is called might be:

[tabs]
====
Cpp::
+
[source,cpp]
----
// The Data Descriptor for Float64
auto descriptor = DataDescriptorBuilder().setSampleType(SampleType::Float64).build();
----
Python::
+
[source,python]
----

----
====

[#last_value_range]
== Getting the last value with a Range

The following example demonstrates casting the `lastValue` object into an `IRange`. Something usefeul we can then do is call the methods of the underlying type and access its members, such as the `getLowValue` (`low_value` in Python) and the `getHighValue` (`high_value` in Python), in this case provided by the `IRange` interface.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Cast to IRange
auto range = lastValue.asPtr<IRange>();
// Extract values
auto low = range.getLowValue();
auto high = range.getHighValue();
----
Python::
+
[source,python]
----

----
====

In the above example, the Data Descriptor of the Data Packet or its Signal on which `getLastValue` (`last_value` in Python) is called is similar to the the one from the previous example (the Data Descriptor with Sample Type `Float64`), except the Sample Type is `RangeInt64`.

[#last_value_complex_number]
== Getting the last value with a Complex Number

In the following example:

* Last value is extracted via a `getLastValue` (`last_value` in Python) call
* `lastValue` object is cast into a `IComplexNumber` type (not needed in Python)
* Methods of the underlying type such as the `getReal` (`real` in Python) and the `getImaginary` (`imaginary` in Python) are called, in this case provided by the `IComplexNumber` interface

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
// Cast to IComplexNumber
auto complex = lastValue.asPtr<IComplexNumber>();
// Extract values
auto real = complex.getReal();
auto imaginary = complex.getImaginary();
----
Python::
+
[source,python]
----

====

A Data Descriptor for this Complex Number example is again very similar to the ones from previous examples, except the Sample Type might be `ComplexFloat32` or `ComplexFloat64` or  instead of `Float64` or `RangeInt64`.

[#last_value_struct]
== Getting the last value with a Struct

A Data Descriptor for a Struct might be:

[tabs]
====
Cpp::
+
[source,cpp]
----
// Create a Data Descriptor
auto descriptor = DataDescriptorBuilder()
					  .setName("MyStruct")
					  .setSampleType(SampleType::Struct)
					  .setStructFields(List<DataDescriptorPtr>(
						  DataDescriptorBuilder()
							  .setName("MyInt32")
							  .setSampleType(SampleType::Int32)
							  .build(),
						  DataDescriptorBuilder()
							  .setName("MyFloat64")
							  .setSampleType(SampleType::Float64)
							  .build()))
					  .build();
// Set the Data Descriptor, thereby adding MyStruct to the Type Manager
signal.setDescriptor(descriptor);
----
Python::
+
[source,python]
----

----
====

In the above example, a Data Descriptor of a custom Struct that has two fields is first built. The first field has Sample Type `Int32` and the second one has Sample Type `Float64`.

[CAUTION]
====
`opendaq.SampleType.Struct` is not yet supported in Python.
====

[NOTE]
====
Because our Struct represents a custom type, we must call `setDescriptor` (`descriptor` in Python) on our Signal in order to add `MyStruct` to the Type Manager.
====

[CAUTION]
====
All custom Structs and their respective fields must have their names set, which is a deviation from the previous examples. In the above code this is done by the calls to `setName` (`name` in Python) method of the Data Descriptor Builder.
====

After some data has been sent to our Signal, we can capture a single value similar to the previous examples:

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
// Cast to IStruct
auto myStruct = lastValue.asPtr<IStruct>();
// Extract values
auto myInt = myStruct.get("MyInt32");
auto myFloat = myStruct.get("MyFloat64");
----
Python::
+
[source,python]
----

----
====

[CAUTION]
====
If we want to call `getLastValue` (`last_value` in Python) on a Data Packet (as opposed to a Signal) and the underlying data type is a Struct, we must provide the optional parameter, Type Manager, which has had the custom Struct added to it.
====

[NOTE]
====
Structs can be nested within the Data Descriptor.
====

[#last_value_list]
== Getting the last value with a List

It's possible for the last value to be a List.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
// Cast to IList
auto myList = lastValue.asPtr<IList>();
// Extract the third item on myList
auto third = myList.getItemAt(2);
----
Python::
+
[source,python]
----

----
====

[NOTE]
====
Dimensions of the Data Descriptor that can be set via the `setDimensions` method (`dimensions` in Python) for Lists in the Data Descriptor Builder and must contain exactly one dimension.
====

[NOTE]
====
Lists may contain (nested) Structs. In such cases, be sure to configure the Data Descriptor appropriately.
====
