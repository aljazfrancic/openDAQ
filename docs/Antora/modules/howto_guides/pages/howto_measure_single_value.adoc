= Measure a single value

OpenDAQ offers a variety of solutions for reading Signal values, including Readers. 

For developers requiring access to only the most recent value, the Signal and Data Packet interfaces provide a method named `getLastValue`.

[#calling_get_last_value_signal]
== Calling `getLastValue` on a Signal

When the `getLastValue` method is called on a Signal, it yields an `BaseObjectPtr` containing the last value.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
----
Python::
+
[source,python]
----
# TODO Python code
----
====

[#calling_get_last_value_data_packet]
== Calling `getLastValue` on a Data Packet

Similar is true when calling the `getLastValue` method on a Data Packet.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Data Packet
auto lastValue = packet.getLastValue();
----
Python::
+
[source,python]
----
# TODO Python code
----
====

[#printing_the_result]
== Printing the result of `getLastValue`

No matter the source (either the Signal or the Data Packet), the resulting variable can be, for example, printed into the console.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Print last value
std::cout << "lastValue: " << lastValue << std::endl;
----
Python::
+
[source,python]
----
# TODO Python code
----
====

[#casting_the_result]
== Casting the result of `getLastValue` and using the cast variable

In C++, if we would like to do something useful with the `BaseObjectPtr`, such as access its underlying methods, we need to cast it into the correct type first. This is not necessary in Python, however.

The underlying type of the `BaseObjectPtr` we get from our `getLastValue` call can be cast into either `IFloat`, if the type is `Float32` or `Float64`, to `IInteger`, if the type is `Int8` through `Int64`, or `UInt8` through `UInt64`, to `IComplexNumber` if type is `ComplexFloat32` or `ComplexFloat64`, to `IRange` if the type is `RangeInt64`, to `IStruct` if the type is `Struct`, and to `IList` of the aforementioned types if there is exactly one dimension in the single value.

In this example, we cast the `lastValue` object into a `RangePtr` type like so:

[tabs]
====
Cpp::
+
[source,cpp]
----
// Cast to RangePtr
auto range = lastValue.asPtr<IRange>();
----
Python::
+
[source,python]
----
# Not needed
----
====

An example of something we could now do is call the methods of the underlying type such as the `getLowValue` and the `getHighValue`, in this case provided by the `IRange` interface.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Call some methods
auto low = range.getLowValue();
auto high = range.getHighValue();
----
Python::
+
[source,python]
----
# TODO Python code
----
====

In the above example the Data Descriptor of the Data Packet or its Signal on which we call `getLastValue` is:

[tabs]
====
Cpp::
+
[source,cpp]
----
// The Data Descriptor for SampleType::RangeInt64
auto descriptor = DataDescriptorBuilder().setSampleType(SampleType::RangeInt64).build();
// Create a Data Packet
auto packet = DataPacket(descriptor, 5);
----
Python::
+
[source,python]
----
# TODO Python code
----
====

In this example, the `sampleCount` of the Data Packet is 5.

[#get_last_value_complex_number]
== `getLastValue` with a Complex Number

A Data Descriptor of a Complex Number might be:

[tabs]
====
Cpp::
+
[source,cpp]
----
// The Data Descriptor for SampleType::ComplexFloat32
auto descriptor = DataDescriptorBuilder().setSampleType(SampleType::ComplexFloat32).build();
// Create a Data Packet
auto packet = DataPacket(descriptor, 5);
----
Python::
+
[source,python]
----
# TODO Python code
----
====

In the above example, the `sampleCount` of the Data Packet is again 5.

In the following example, we first extract the last value via `getLastValue` call, then we cast the `lastValue` object into a `ComplexNumberPtr` type (C++ only). Lastly, call the methods of the underlying type such as the `getReal` and the `getImaginary`, in this case provided by the `IComplexNumber` interface.

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
// Cast to ComplexNumberPtr
auto complex = lastValue.asPtr<IComplexNumber>();
// Call some methods
auto real = complex.getReal();
auto imaginary = complex.getImaginary();
----
Python::
+
[source,python]
----
# TODO Python code
----
====

[#get_last_value_struct]
== `getLastValue` with a Struct

A Data Descriptor of a Struct might be:

[tabs]
====
Cpp::
+
[source,cpp]
----
// Create a Data Descriptor
auto descriptor = DataDescriptorBuilder()
					  .setName("MyStruct")
					  .setSampleType(SampleType::Struct)
					  .setStructFields(List<DataDescriptorPtr>(
						  DataDescriptorBuilder()
							  .setName("MyInt32")
							  .setSampleType(SampleType::Int32)
							  .build(),
						  DataDescriptorBuilder()
							  .setName("MyFloat64")
							  .setSampleType(SampleType::Float64)
							  .build()))
					  .build();
// Set the Data Descriptor, thereby adding MyStruct to the Type Manager
signal.setDescriptor(descriptor);
// Create a Data Packet
auto packet = DataPacket(descriptor, 5);
----
Python::
+
[source,python]
----
# TODO Python code
----
====

In the above example, we first build a Data Descriptor of a custom Struct that has two fields. The first field has Sample Type `SampleType::Int32` and the second one has Sample Type `SampleType::Float64`.

[NOTE]
====
Because our Struct represents a custom type, we must call `setDescriptor` on our Signal in order to add `MyStruct` to the Type Manager.
====

[CAUTION]
====
All custom Structs and their respective fields must have their names set, which is a deviation from the previous examples. In the above code this is done by the calls to `setName` method of the Data Descriptor Builder.
====

After some data has been sent to our Signal, we can capture a single value similar to the previous examples:

[tabs]
====
Cpp::
+
[source,cpp]
----
// Get last value of a Signal
auto lastValue = signal.getLastValue();
// Cast to StructPtr
auto myStruct = lastValue.asPtr<IStruct>();
// Extract both values
auto myInt = myStruct.get("MyInt32");
auto myFloat = myStruct.get("MyFloat64");
----
Python::
+
[source,python]
----
# TODO Python code
----
====

for data packet must provide optional arg (USE CAUTION/WARNING IN MARKUP)
and can be nested

[#get_last_value_list]
== `getLastValue` with a List

TODO LIST + DIMENSIONS + CAN BE NESTED

